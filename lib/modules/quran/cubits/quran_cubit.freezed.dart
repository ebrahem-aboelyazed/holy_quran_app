// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'quran_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$QuranState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuranStateCopyWith<$Res> {
  factory $QuranStateCopyWith(
          QuranState value, $Res Function(QuranState) then) =
      _$QuranStateCopyWithImpl<$Res, QuranState>;
}

/// @nodoc
class _$QuranStateCopyWithImpl<$Res, $Val extends QuranState>
    implements $QuranStateCopyWith<$Res> {
  _$QuranStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialQuranImplCopyWith<$Res> {
  factory _$$InitialQuranImplCopyWith(
          _$InitialQuranImpl value, $Res Function(_$InitialQuranImpl) then) =
      __$$InitialQuranImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialQuranImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$InitialQuranImpl>
    implements _$$InitialQuranImplCopyWith<$Res> {
  __$$InitialQuranImplCopyWithImpl(
      _$InitialQuranImpl _value, $Res Function(_$InitialQuranImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialQuranImpl implements InitialQuran {
  const _$InitialQuranImpl();

  @override
  String toString() {
    return 'QuranState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialQuranImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialQuran implements QuranState {
  const factory InitialQuran() = _$InitialQuranImpl;
}

/// @nodoc
abstract class _$$QuranLoadingImplCopyWith<$Res> {
  factory _$$QuranLoadingImplCopyWith(
          _$QuranLoadingImpl value, $Res Function(_$QuranLoadingImpl) then) =
      __$$QuranLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuranLoadingImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$QuranLoadingImpl>
    implements _$$QuranLoadingImplCopyWith<$Res> {
  __$$QuranLoadingImplCopyWithImpl(
      _$QuranLoadingImpl _value, $Res Function(_$QuranLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QuranLoadingImpl implements QuranLoading {
  const _$QuranLoadingImpl();

  @override
  String toString() {
    return 'QuranState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuranLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class QuranLoading implements QuranState {
  const factory QuranLoading() = _$QuranLoadingImpl;
}

/// @nodoc
abstract class _$$QuranLoadedImplCopyWith<$Res> {
  factory _$$QuranLoadedImplCopyWith(
          _$QuranLoadedImpl value, $Res Function(_$QuranLoadedImpl) then) =
      __$$QuranLoadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuranLoadedImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$QuranLoadedImpl>
    implements _$$QuranLoadedImplCopyWith<$Res> {
  __$$QuranLoadedImplCopyWithImpl(
      _$QuranLoadedImpl _value, $Res Function(_$QuranLoadedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QuranLoadedImpl implements QuranLoaded {
  const _$QuranLoadedImpl();

  @override
  String toString() {
    return 'QuranState.loaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuranLoadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return loaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class QuranLoaded implements QuranState {
  const factory QuranLoaded() = _$QuranLoadedImpl;
}

/// @nodoc
abstract class _$$QuranNotLoadedImplCopyWith<$Res> {
  factory _$$QuranNotLoadedImplCopyWith(_$QuranNotLoadedImpl value,
          $Res Function(_$QuranNotLoadedImpl) then) =
      __$$QuranNotLoadedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuranNotLoadedImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$QuranNotLoadedImpl>
    implements _$$QuranNotLoadedImplCopyWith<$Res> {
  __$$QuranNotLoadedImplCopyWithImpl(
      _$QuranNotLoadedImpl _value, $Res Function(_$QuranNotLoadedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QuranNotLoadedImpl implements QuranNotLoaded {
  const _$QuranNotLoadedImpl();

  @override
  String toString() {
    return 'QuranState.notLoaded()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuranNotLoadedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return notLoaded();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return notLoaded?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (notLoaded != null) {
      return notLoaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return notLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return notLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (notLoaded != null) {
      return notLoaded(this);
    }
    return orElse();
  }
}

abstract class QuranNotLoaded implements QuranState {
  const factory QuranNotLoaded() = _$QuranNotLoadedImpl;
}

/// @nodoc
abstract class _$$QuranUpdatingImplCopyWith<$Res> {
  factory _$$QuranUpdatingImplCopyWith(
          _$QuranUpdatingImpl value, $Res Function(_$QuranUpdatingImpl) then) =
      __$$QuranUpdatingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuranUpdatingImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$QuranUpdatingImpl>
    implements _$$QuranUpdatingImplCopyWith<$Res> {
  __$$QuranUpdatingImplCopyWithImpl(
      _$QuranUpdatingImpl _value, $Res Function(_$QuranUpdatingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QuranUpdatingImpl implements QuranUpdating {
  const _$QuranUpdatingImpl();

  @override
  String toString() {
    return 'QuranState.updating()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuranUpdatingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return updating();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return updating?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return updating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return updating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (updating != null) {
      return updating(this);
    }
    return orElse();
  }
}

abstract class QuranUpdating implements QuranState {
  const factory QuranUpdating() = _$QuranUpdatingImpl;
}

/// @nodoc
abstract class _$$QuranUpdatedImplCopyWith<$Res> {
  factory _$$QuranUpdatedImplCopyWith(
          _$QuranUpdatedImpl value, $Res Function(_$QuranUpdatedImpl) then) =
      __$$QuranUpdatedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$QuranUpdatedImplCopyWithImpl<$Res>
    extends _$QuranStateCopyWithImpl<$Res, _$QuranUpdatedImpl>
    implements _$$QuranUpdatedImplCopyWith<$Res> {
  __$$QuranUpdatedImplCopyWithImpl(
      _$QuranUpdatedImpl _value, $Res Function(_$QuranUpdatedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$QuranUpdatedImpl implements QuranUpdated {
  const _$QuranUpdatedImpl();

  @override
  String toString() {
    return 'QuranState.updated()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$QuranUpdatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() loaded,
    required TResult Function() notLoaded,
    required TResult Function() updating,
    required TResult Function() updated,
  }) {
    return updated();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? loaded,
    TResult? Function()? notLoaded,
    TResult? Function()? updating,
    TResult? Function()? updated,
  }) {
    return updated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? loaded,
    TResult Function()? notLoaded,
    TResult Function()? updating,
    TResult Function()? updated,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialQuran value) initial,
    required TResult Function(QuranLoading value) loading,
    required TResult Function(QuranLoaded value) loaded,
    required TResult Function(QuranNotLoaded value) notLoaded,
    required TResult Function(QuranUpdating value) updating,
    required TResult Function(QuranUpdated value) updated,
  }) {
    return updated(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(InitialQuran value)? initial,
    TResult? Function(QuranLoading value)? loading,
    TResult? Function(QuranLoaded value)? loaded,
    TResult? Function(QuranNotLoaded value)? notLoaded,
    TResult? Function(QuranUpdating value)? updating,
    TResult? Function(QuranUpdated value)? updated,
  }) {
    return updated?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialQuran value)? initial,
    TResult Function(QuranLoading value)? loading,
    TResult Function(QuranLoaded value)? loaded,
    TResult Function(QuranNotLoaded value)? notLoaded,
    TResult Function(QuranUpdating value)? updating,
    TResult Function(QuranUpdated value)? updated,
    required TResult orElse(),
  }) {
    if (updated != null) {
      return updated(this);
    }
    return orElse();
  }
}

abstract class QuranUpdated implements QuranState {
  const factory QuranUpdated() = _$QuranUpdatedImpl;
}
